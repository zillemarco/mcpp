/*-
 * Copyright (c) 1998, 2002-2008 Kiyoshi Matsui <kmatsui@t3.rim.or.jp>
 * All rights reserved.
 *
 * Some parts of this code are derived from the public domain software
 * DECUS cpp (1984,1985) written by Martin Minow.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *                              M A I N . C
 *                  M C P P   M a i n   P r o g r a m
 *
 * The main routine and it's supplementary routines are placed here.
 * The post-preprocessing routines are also placed here.
 */

#if PREPROCESSED /* Use "pre-preprocessed" header    */
#include "mcpp.H"
#else
#include "system.H"
#include "internal.H"
#endif

void setup_processing_data(processing_data_t* data)
{
    /*
     * The boolean flags specified by the execution options.
     * lang_asm allows the following non-standard features.
     * 1. #non-directive.
     * 2. <newline> in a string-literal.
     * 3. invalid pp-token generated by ## operator.
     * lang_asm is not available in POST_STD mode.
     * When COMPILER == GNUC, -x assembler-with-cpp or -lang-asm options
     * are used instead of -a.
     */
    data->option_flags.c = FALSE;               /* c:   -C (keep comments)                          */
    data->option_flags.k = FALSE;               /* k:   -k (keep horizontal white spaces)           */
    data->option_flags.z = FALSE;               /* z:   -z (no output of included files)            */
    data->option_flags.p = FALSE;               /* p:   -P (no #line output)                        */
    data->option_flags.q = FALSE;               /* q:   -Q (output diagnosis to mcpp.err)           */
    data->option_flags.v = FALSE;               /* v:   -v (verbose, affects macro notification)    */
    data->option_flags.trig = TRIGRAPHS_INIT;   /* trig:    -3 (toggle trigraphs)                   */
    data->option_flags.dig = DIGRAPHS_INIT;     /* dig: -2 (toggle digraphs recognition)            */
    data->option_flags.lang_asm = FALSE;        /* lang_asm:    -a (assembler source)               */
    data->option_flags.no_source_line = FALSE;  /* no_source_line:  -j (no source line in diag)     */
    data->option_flags.dollar_in_name = FALSE;

    data->mcpp_mode = STD; /* Mode of preprocessing        */

    data->cplus_val = 0L;   /*  Value of __cplusplus for C++ */
    data->stdc_ver = 0L;    /*  Value of __STDC_VERSION__    */
    data->stdc_val = 0;     /*  Value of __STDC__            */
    data->stdc2;            /*  cplus_val || stdc_ver >= 199901L */
    data->stdc3;            /*  cplus_val >= 199901L || stdc_ver >= 199901L.
                                (cplus_val >= 199901L) specifies compatible mode to C99 (extended
                                feature of this preprocessor) */
    data->standard = TRUE;  /* TRUE, if mcpp_mode is STD or POST_STD    */
    data->std_line_prefix = STD_LINE_PREFIX;

    /*
    * Commonly used global variables:
    * src_line     is the current input line number.
    * wrong_line   is set in many places when the actual output line is out of
    *              sync with the numbering, e.g, when expanding a macro with an
    *              embedded newline.
    * identifier   holds the last identifier scanned (which might be a candidate
    *              for macro expansion).
    * errors       is the running mcpp error counter.
    * infile       is the head of a linked list of input files (extended by
    *              #include and macros being expanded).  'infile' always points
    *              to the current file/macro.  'infile->parent' to the includer,
    *              etc.  'infile->fp' is NULL if this input stream is not a file.
    * inc_dirp     Directory of #includer with trailing PATH_DELIM.  This points
    *              to one of incdir[] or to the current directory (represented as
    *              "".  This should not be NULL.
    */
    // data->src_line;             /* Current line number                  */
    // data->wrong_line;           /* Force #line to compiler              */
    // data->newlines;             /* Count of blank lines                 */
    data->errors = 0;           /* Cpp error counter                    */
    data->warn_level = -1;      /* Level of warning (have to initialize)*/
    data->infile = NULL;        /* Current input file                   */
    data->include_nest = 0;     /* Nesting level of #include            */
    data->null = "";            /* "" string for convenience            */
    // inc_dirp;                /* Directory of #includer       */
    // cur_fname;               /* Current source file name. cur_fname is not rewritten by #line directive    */
    // cur_fullname;            /* Full path of current source file (i.e. infile->full_fname)       */
    // no_source_line;          /* Do not output line in diag.  */
    // identifier;              /* Current identifier   */
    data->mcpp_debug = 0;       /* != 0 if debugging now                */

    /*
    * in_directive is set TRUE while a directive line is scanned by directive().
    * It modifies the behavior of squeeze_ws() in expand.c so that newline is
    * not skipped even if getting macro arguments.
    */
    data->in_directive = FALSE; /* TRUE scanning directive line */
    data->in_define = FALSE;    /* TRUE scanning #define line   */
    data->in_getarg = FALSE;    /* TRUE collecting macro arguments      */
    data->in_include = FALSE;   /* TRUE scanning #include line  */
    data->in_if = FALSE;        /* TRUE scanning #if and in non-skipped expr.   */
    data->in_asm = 0L;          /* Starting line of #asm - #endasm block*/

    /*
    * macro_line is set to the line number of start of a macro call while
    * expanding the macro, else set to 0.  Line number is remembered for
    * diagnostics of unterminated macro call.  On unterminated macro call
    * macro_line is set to MACRO_ERROR.
    */
    data->macro_line = 0L;
    
    // /* macro_name is the currently expanding macro. */
    // data->macro_name;

    // /* openum is the return value of scan_op() in support.c. */
    // data->openum;

    /*
    * mkdep means to output source file dependency line, specified by -M*
    * option.  The OR of the following values is used.
    *      MD_MKDEP    (1) :   Output dependency line.
    *      MD_SYSHEADER(2) :   Print also system headers or headers with
    *          absolute path not only user headers.
    *      MD_FILE     (4) :   Output to the file named *.d instead of fp_out.
    *          Normal output is done to fp_out as usual.
    */
    data->mkdep = 0;

    /*
    * If option_flags.z is TRUE, no_output is incremented when a file is
    * #included, and decremented when the file is finished.
    * If no_output is larger than 0, processed files are not output, meanwhile
    * the macros in the files are defined.
    * If mkdep != 0 && (mkdep & MD_FILE) == 0, no_output is set to 1 initially.
    */
    data->no_output = 0;

    /*
    * keep_comments is set TRUE by the -C option.  If TRUE, comments are written
    * directly to the output stream.  option_flags.c contains the permanent state
    * of the -C option.  keep_comments is always falsified when compilation is
    * supressed by a false #if or when no_output is TRUE.
    */
    data->keep_comments = 0; /* Write out comments flag  */

    /*
    * keep_spaces is set to TRUE by the -k option.  If TRUE, spaces and tabs in
    * an input line are written out to the output line without squeezing to one
    * space.  option_flags.k contains the permanent state of the -k option.
    * keep_spaces is falsified when compilation is suppressed by a false #if.
    */
    data->keep_spaces = 0; /* Keep white spaces of line*/

    /*
    * ifstack[] holds information about nested #if's.  It is always accessed via
    * ifptr->stat.  The information is as follows:
    *      WAS_COMPILING   state of compiling flag at outer level.
    *      ELSE_SEEN       set TRUE when #else seen to prevent 2nd #else.
    *      TRUE_SEEN       set TRUE when #if or #elif succeeds
    * ifstack[0].stat holds the compiling flag.  It is WAS_COMPILING if compila-
    * tion is currently enabled.  Note that this must be initialized to
    * WAS_COMPILING.
    */
    data->ifstack[0].stat = WAS_COMPILING;
    data->ifstack[0].ifline = 0L;
    data->ifstack[0].elseline = 0L;

    /* Note: '+1' is necessary for the initial state.   */
    data->ifptr = data->ifstack; /* -> current ifstack[]     */

    /*
    * In POST_STD mode, insert_sep is set to INSERT_SEP when :
    *  1. the next get_ch() shall insert a token separator.
    *  2. unget_ch() has been called when insert_sep == INSERTED_SEP.
    * set to INSERTED_SEP when :
    *  get_ch() has been called when insert_sep == INSERT_SEP.
    * set to NO_SEP when :
    *  get_ch() has been called when insert_sep == INSERTED_SEP.
    */
    data->insert_sep = NO_SEP;

    // /* File pointers for input and output.  */
    // data->mf_in;   // Anima ADD
    // data->fp_out;   /* Output stream preprocessed   */
    // data->fp_err;   /* Diagnostics stream           */
    // data->fp_debug; /* Debugging information stream */

    /* Variables on multi-byte character encodings. */
    data->mbchar = MBCHAR; /* Encoding of multi-byte char  */
    // data->mbchk;           /* Character type of possible multi-byte char   */
    // data->bsl_in_mbchar;   /* 2nd byte of mbchar possibly has '\\' */
    // data->bsl_need_escape; /* '\\' in MBCHAR should be escaped */
    
    // data->error_exit; /* Exit on fatal error          */

    /* Translation limits specified by C90, C99 or C++. */
    data->std_limits.str_len = NBUFF;
    data->std_limits.id_len = IDMAX;
    data->std_limits.n_mac_pars = NMACPARS;

    /*
    * work_buf[] and workp are used to store one piece of text as a temporary
    * buffer.
    * To initialize storage, set workp = work_buf.  Note that the work buffer is
    * used by several subroutines -- be sure that your data won't be overwritten.
    * work_buf[] is used for:
    *      1. macro expansion (def_special(), prescan(), catenate(),
    *         stringize()).
    *      2. processing directive line (directive.c, eval.c, get_unexpandable(),
    *         do_pragma() and its subroutines).
    *      3. processing _Pragma() operator (do_pragma_op()).
    *      4. miscellaneous (init_gcc_macro(), curfile()). 
    */
    // data->work_buf; /* Work buffer      */
    // data->workp;                  /* Pointer into work_buf[]      */
    data->work_end = &data->work_buf[NWORK]; /* End of buffer of work_buf[]  */

    /*
    * src_col      is the current input column number, but is rarely used.
    *              It is used to put spaces after #line line in keep_spaces mode
    *              on some special cases.
    */
    data->src_col = 0; /* Column number of source line */
    
    /*
    * output[] and out_ptr are used for:
    *      buffer to store preprocessed line (this line is put out or handed to
    *      post_preproc() via putout() in some cases)
    */
    data->out_end = &data->output[NWORK - 2];

    /* Limit of output line for other than GCC and VC   */
    data->out_wend = &data->output[NMACWORK - 2];

    // /* Buffer end of output line    */
    // data->out_ptr; /* Current pointer into output[]*/

    data->num_of_macro = 0;

    data->skip = 0;

    data->macrosProcessingData.has_pragma = FALSE;

    data->supportProcessingData.exp_mac_ind = 0;        /* Index into expanding_macro[] */
    data->supportProcessingData.in_token = FALSE;       /* For token scanning functions */
    data->supportProcessingData.in_string = FALSE;      /* For get_ch() and parse_line()*/
    data->supportProcessingData.squeezews = FALSE;
    data->supportProcessingData.dollar_diagnosed = FALSE;
    
    #if MCPP_LIB
        data->supportProcessingData.use_mem_buffers = FALSE;
    #endif

    data->mcpp_fputc = NULL;
    data->mcpp_fputs = NULL;
    data->mcpp_fprintf = NULL;

    data->systemData.mcpp_optind = 1;
    data->systemData.mcpp_opterr = 1;
    data->systemData.mb_changed = FALSE;
    data->systemData.search_rule = SEARCH_INIT;
    data->systemData.nflag = FALSE;
    data->systemData.std_val = -1L;
    data->systemData.sharp_filename = NULL;
    
    #if COMPILER == GNUC
    data->systemData.sys_dirp = NULL;
    data->systemData.sysroot = NULL;
    data->systemData.i_split = FALSE;
    data->systemData.gcc_work_dir = FALSE;
    data->systemData.gcc_maj_ver;
    data->systemData.gcc_min_ver;
    data->systemData.dDflag = FALSE;
    data->systemData.dMflag = FALSE;
    #endif
    
    #if COMPILER == MSC
    data->systemData.wchar_t_modified = FALSE;
    #endif

    #if COMPILER == LCC
    data->systemData.optim_name = "__LCCOPTIMLEVEL";
    #endif

    #if SYSTEM == SYS_CYGWIN
    data->systemData.no_cygwin = FALSE;
    #endif

    data->systemData.diagnosed = FALSE;
}


#define MBCHAR_IS_ESCAPE_FREE (SJIS_IS_ESCAPE_FREE && \
                               BIGFIVE_IS_ESCAPE_FREE && ISO2022_JP_IS_ESCAPE_FREE)

#if MCPP_LIB
static void init_main(processing_data_t* processingData);
/* Initialize static variables      */
#endif
static void init_defines(processing_data_t* processingData);
/* Predefine macros                 */
static void mcpp_main(processing_data_t* processingData);
/* Main loop to process input lines */
static void do_pragma_op(processing_data_t* processingData);
/* Execute the _Pragma() operator   */
static void put_seq(char *begin, char *seq, processing_data_t* processingData);
/* Put out the failed sequence      */
static char *de_stringize(char *in, char *out);
/* "De-stringize" for _Pragma() op. */
static void putout(char *out, processing_data_t* processingData);
/* May concatenate adjacent string  */
#if COMPILER != GNUC && COMPILER != MSC
static void devide_line(char *out, processing_data_t* processingData);
/* Devide long line for compiler    */
#endif
static void put_a_line(char *out, processing_data_t* processingData);
/* Put out the processed line       */
#if !HAVE_DIGRAPHS || !MBCHAR_IS_ESCAPE_FREE
static int post_preproc(char *out);
/* Post-preprocess for older comps  */
#if !HAVE_DIGRAPHS
static char *conv_a_digraph(char *cp);
/* Convert a digraph in place       */
#endif
#if !MBCHAR_IS_ESCAPE_FREE
static char *esc_mbchar(char *str, char *str_end);
/* Double \ as 2nd byte of SJIS     */
#endif
#endif

#if MCPP_LIB
static void init_main(processing_data_t* processingData)
/* Initialize global variables on re-entering.  */
{
    processingData->mcpp_mode = STD;
    processingData->cplus_val = processingData->stdc_ver = 0L;
    processingData->stdc_val = 0;
    processingData->standard = TRUE;
    processingData->std_line_prefix = STD_LINE_PREFIX;
    processingData->errors = processingData->src_col = 0;
    processingData->warn_level = -1;
    processingData->infile = NULL;
    processingData->in_directive = processingData->in_define = processingData->in_getarg = processingData->in_include = processingData->in_if = FALSE;
    processingData->src_line = processingData->macro_line = processingData->in_asm = 0L;
    processingData->mcpp_debug = processingData->mkdep = processingData->no_output = processingData->keep_comments = processingData->keep_spaces = 0;
    processingData->include_nest = 0;
    processingData->insert_sep = NO_SEP;
    processingData->mbchar = MBCHAR;
    processingData->ifptr = processingData->ifstack;
    processingData->ifstack[0].stat = WAS_COMPILING;
    processingData->ifstack[0].ifline = processingData->ifstack[0].elseline = 0L;
    processingData->std_limits.str_len = NBUFF;
    processingData->std_limits.id_len = IDMAX;
    processingData->std_limits.n_mac_pars = NMACPARS;
    processingData->option_flags.c = processingData->option_flags.k = processingData->option_flags.z = processingData->option_flags.p = processingData->option_flags.q = processingData->option_flags.v = processingData->option_flags.lang_asm = processingData->option_flags.no_source_line = processingData->option_flags.dollar_in_name = FALSE;
    processingData->option_flags.trig = TRIGRAPHS_INIT;
    processingData->option_flags.dig = DIGRAPHS_INIT;
}

int mcpp_lib_main(int argc, char **argv, processing_data_t* processingData)
{
#else
int main(int argc, char **argv)
{
    processing_data_t localProcessingData;
    processing_data_t* processingData = &localProcessingData;
    setup_processing_data(processingData);
#endif
    
    char *in_file = NULL;
    char *out_file = NULL;
    char *stdin_name = "<stdin>";

    if (setjmp(processingData->error_exit) == -1)
    {
        processingData->errors++;
        goto fatal_error_exit;
    }

#if MCPP_LIB
    /* Initialize global and static variables.  */
    init_main(processingData);
    init_directive(processingData);
    init_eval(processingData);
    init_support(processingData);
    init_system(processingData);
#endif

    processingData->mf_in = 0;
    processingData->fp_out = stdout;
    processingData->fp_err = stderr;
    processingData->fp_debug = stdout;   /* Debugging information is output to stdout in order to synchronize with preprocessed output. */
    
    processingData->inc_dirp = &processingData->null;                            /* Initialize to current (null) directory   */
    processingData->cur_fname = processingData->cur_fullname = "(predefined)";   /* For predefined macros    */

    mcpp_init_def_out_func(processingData);
    init_defines(processingData);               /* Predefine macros     */
    mb_init(processingData);                    /* Should be initialized prior to get options   */
    do_options(argc, argv, &in_file, &out_file, processingData); /* Command line options */

    /* Open input file, "-" means stdin.    */
    if (in_file != NULL && !str_eq(in_file, "-"))
    {
        //if ((fp_in = fopen( in_file, "r")) == NULL) {		// Anima ADD
        if ((processingData->mf_in = mfopen(in_file)) == NULL)
        { // Anima ADD
            processingData->mcpp_fprintf(ERR, processingData, "Can't open input file \"%s\".\n", in_file);
            processingData->errors++;
#if MCPP_LIB
            goto fatal_error_exit;
#else
            return (IO_ERROR);
#endif
        }
    }
    else
    {
        in_file = stdin_name;
    }

    /* Open output file, "-" means stdout.  */
    if (out_file != NULL && !str_eq(out_file, "-"))
    {
        if ((processingData->fp_out = fopen(out_file, "w")) == NULL)
        {
            processingData->mcpp_fprintf(ERR, processingData, processingData, "Can't open output file \"%s\".\n", out_file);
            processingData->errors++;
#if MCPP_LIB
            goto fatal_error_exit;
#else
            return (IO_ERROR);
#endif
        }

        processingData->fp_debug = processingData->fp_out;
    }

    if (processingData->option_flags.q)
    { /* Redirect diagnostics */
        if ((processingData->fp_err = fopen("mcpp.err", "a")) == NULL)
        {
            processingData->errors++;
            processingData->mcpp_fprintf(OUT, processingData, "Can't open \"mcpp.err\"\n");
#if MCPP_LIB
            goto fatal_error_exit;
#else
            return (IO_ERROR);
#endif
        }
    }

    init_sys_macro(processingData);                               /* Initialize system-specific macros    */
    add_file(processingData->mf_in, NULL, in_file, in_file, FALSE, processingData); // Anima ADD

    /* "open" main input file   */
    processingData->infile->dirp = processingData->inc_dirp;
    processingData->infile->sys_header = FALSE;
    processingData->cur_fullname = in_file;

    if (processingData->mkdep && str_eq(processingData->infile->real_fname, stdin_name) == FALSE)
    {
        put_depend(in_file, processingData); /* Putout target file name      */
    }

    at_start(processingData);              /* Do the pre-main commands     */

    mcpp_main(processingData); /* Process main file            */

    if (processingData->mkdep)
    {
        put_depend(NULL, processingData); /* Append '\n' to dependency line   */
    }

    at_end(processingData);             /* Do the final commands        */

fatal_error_exit:
#if MCPP_LIB
    /* Free malloced memory */
    if (processingData->mcpp_debug & MACRO_CALL)
    {
        if (in_file != stdin_name)
            free(in_file);
    }
    clear_filelist(processingData);
    clear_symtable(processingData);
#endif

    //if (fp_in != stdin)	// Anima ADD
    //    fclose( fp_in);	// Anima ADD
    mfclose(processingData->mf_in); // Anima ADD
    
    if (processingData->fp_out != stdout)
        fclose(processingData->fp_out);

    if (processingData->fp_err != stderr)
        fclose(processingData->fp_err);

    if (processingData->mcpp_debug & MEMORY)
        print_heap();

    if (processingData->errors > 0 && processingData->option_flags.no_source_line == FALSE)
    {
        processingData->mcpp_fprintf(ERR, processingData, "%d error%s in preprocessor.\n", processingData->errors, (processingData->errors == 1) ? "" : "s");
        return IO_ERROR;
    }

    return IO_SUCCESS; /* No errors    */
}

// Anima ADD
#define MAX_OPTIONS 128
int mcpp_run(
    const char *in_options,
    const char *filename,
    char **outfile,
    char **outerrors,
    file_loader in_file_loader)
{
    int ret = 0;
    int argc = 0;
    char *argv[MAX_OPTIONS];
    char *options = 0;
    char *p = 0;

    argv[argc++] = "mcpp";
    argv[argc++] = filename;

    p = malloc(strlen(in_options) + 1);
    if (p)
    {
        strcpy(p, in_options);
    }

    options = p;

    if (p)
    {
        while (*p && argc < MAX_OPTIONS)
        {
            // Skip whitespace.
            while (*p && (*p == ' ' || *p == '\t'))
            {
                p++;
            }
            // Store pointer to argument.
            argv[argc++] = p;
            // Skip argument.
            while (*p && *p != ' ' && *p != '\t')
            {
                p++;
            }
            // Add null terminator for argument if needed.
            if (*p)
            {
                *p++ = 0;
            }
        }
    }

    processing_data_t localProcessingData;
    setup_processing_data(&localProcessingData);
    mcpp_use_mem_buffers(1, &localProcessingData);
    mfset(in_file_loader);
    ret = mcpp_lib_main(argc, argv, &localProcessingData);
    if (outfile)
    {
        *outfile = mcpp_get_mem_buffer(OUT, &localProcessingData);
    }
    if (outerrors)
    {
        *outerrors = mcpp_get_mem_buffer(ERR, &localProcessingData);
    }
    free(options);

    return ret;
}
// Anima ADD

/*
 * This is the table used to predefine target machine, operating system and
 * compiler designators.  It may need hacking for specific circumstances.
 * The -N option supresses these definitions.
 */
typedef struct pre_set
{
    const char *name;
    const char *val;
} PRESET;

static PRESET preset[] = {

#ifdef SYSTEM_OLD
    {SYSTEM_OLD, "1"},
#endif
#ifdef SYSTEM_SP_OLD
    {SYSTEM_SP_OLD, "1"},
#endif
#ifdef COMPILER_OLD
    {COMPILER_OLD, "1"},
#endif
#ifdef COMPILER_SP_OLD
    {COMPILER_SP_OLD, "1"},
#endif

    {NULL, NULL}, /* End of macros beginning with alphabet    */

#ifdef SYSTEM_STD
    {SYSTEM_STD, "1"},
#endif
#ifdef SYSTEM_STD1
    {SYSTEM_STD1, "1"},
#endif
#ifdef SYSTEM_STD2
    {SYSTEM_STD2, "1"},
#endif

#ifdef SYSTEM_EXT
    {SYSTEM_EXT, SYSTEM_EXT_VAL},
#endif
#ifdef SYSTEM_EXT2
    {SYSTEM_EXT2, SYSTEM_EXT2_VAL},
#endif
#ifdef SYSTEM_SP_STD
    {SYSTEM_SP_STD, SYSTEM_SP_STD_VAL},
#endif
#ifdef COMPILER_STD
    {COMPILER_STD, COMPILER_STD_VAL},
#endif
#ifdef COMPILER_STD1
    {COMPILER_STD1, COMPILER_STD1_VAL},
#endif
#ifdef COMPILER_STD2
    {COMPILER_STD2, COMPILER_STD2_VAL},
#endif
#ifdef COMPILER_EXT
    {COMPILER_EXT, COMPILER_EXT_VAL},
#endif
#ifdef COMPILER_EXT2
    {COMPILER_EXT2, COMPILER_EXT2_VAL},
#endif
#ifdef COMPILER_SP_STD
    {COMPILER_SP_STD, COMPILER_SP_STD_VAL},
#endif
#ifdef COMPILER_SP1
    {COMPILER_SP1, COMPILER_SP1_VAL},
#endif
#ifdef COMPILER_SP2
    {COMPILER_SP2, COMPILER_SP2_VAL},
#endif
#ifdef COMPILER_SP3
    {COMPILER_SP3, COMPILER_SP3_VAL},
#endif
#ifdef COMPILER_CPLUS
    {COMPILER_CPLUS, COMPILER_CPLUS_VAL},
#endif
    {NULL, NULL}, /* End of macros with value of any integer  */
};

static void init_defines(processing_data_t* processingData)
/*
 * Initialize the built-in #define's.
 * Called only on cpp startup prior to do_options().
 *
 * Note: the built-in static definitions are removed by the -N option.
 */
{
    int n = sizeof preset / sizeof(PRESET);
    int nargs;
    PRESET *pp;

    /* Predefine the built-in symbols.  */
    nargs = DEF_NOARGS_PREDEF_OLD;
    for (pp = preset; pp < preset + n; pp++)
    {
        if (pp->name && *(pp->name))
            look_and_install(pp->name, nargs, processingData->null, pp->val, processingData);
        else if (!pp->name)
            nargs = DEF_NOARGS_PREDEF;
    }

    look_and_install("__MCPP", DEF_NOARGS_PREDEF, processingData->null, "2", processingData);
    /* MCPP V.2.x   */
    /* This macro is predefined and is not undefined by -N option,  */
    /*      yet can be undefined by -U or #undef.                   */
}

void un_predefine(
    int clearall, /* TRUE for -N option   */
    processing_data_t* processingData
)
/*
 * Remove predefined symbols from the symbol table.
 */
{
    PRESET *pp;
    DEFBUF *defp;
    int n = sizeof preset / sizeof(PRESET);

    for (pp = preset; pp < preset + n; pp++)
    {
        if (pp->name)
        {
            if (*(pp->name) && (defp = look_id(pp->name, processingData)) != NULL && defp->nargs >= DEF_NOARGS_PREDEF)
                undefine(pp->name, processingData);
        }
        else if (clearall == FALSE)
        { /* -S<n> option */
            break;
        }
    }
}

static void mcpp_main(processing_data_t* processingData)
/*
 * Main process for mcpp -- copies tokens from the current input stream
 * (main file or included file) to the output file.
 */
{
    int c;             /* Current character            */
    char *wp;          /* Temporary pointer            */
    DEFBUF *defp;      /* Macro definition             */
    int line_top;      /* Is in the line top, possibly spaces  */
    LINE_COL line_col; /* Location of macro call in source     */

    processingData->keep_comments = processingData->option_flags.c && !processingData->no_output;
    processingData->keep_spaces = processingData->option_flags.k; /* Will be turned off if !compiling */
    line_col.col = line_col.line = 0L;

    /*
     * This loop is started "from the top" at the beginning of each line.
     * 'wrong_line' is set TRUE in many places if it is necessary to write
     * a #line record.  (But we don't write them when expanding macros.)
     *
     * 'newlines' variable counts the number of blank lines that have been
     * skipped over.  These are then either output via #line records or
     * by outputting explicit blank lines.
     * 'newlines' will be cleared on end of an included file by get_ch().
     */
    while (1)
    {                 /* For the whole input  */
        processingData->newlines = 0; /* Count empty lines    */

        while (1)
        {                     /* For each line, ...   */
            processingData->out_ptr = processingData->output; /* Top of the line buf  */
            c = get_ch(processingData);

            if (processingData->src_col)
                break; /* There is a residual tokens on the line   */

            while (processingData->char_type[c] & HSP)
            { /* ' ' or '\t'          */
                if (c != COM_SEP)
                    *processingData->out_ptr++ = c; /* Retain line top white spaces */
                                    /* Else skip 0-length comment   */
                c = get_ch(processingData);
            }
            if (c == '#')
            {                /* Is 1st non-space '#' */
                directive(processingData); /* Do a #directive      */
            }
            else if (processingData->mcpp_mode == STD && processingData->option_flags.dig && c == '%')
            {
                /* In POST_STD digraphs are already converted   */
                if (get_ch(processingData) == ':')
                {                /* '%:' i.e. '#'        */
                    directive(processingData); /* Do a #directive      */
                }
                else
                {
                    unget_ch(processingData);
                    if (!processingData->compiling)
                    {
                        skip_nl(processingData);
                        processingData->newlines++;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else if (c == CHAR_EOF)
            { /* End of input         */
                break;
            }
            else if (!processingData->compiling)
            {               /* #ifdef false?        */
                skip_nl(processingData);  /* Skip to newline      */
                processingData->newlines++; /* Count it, too.       */
            }
            else if (processingData->in_asm && !processingData->no_output)
            {              /* In #asm block    */
                put_asm(); /* Put out as it is     */
            }
            else if (c == '\n')
            { /* Blank line           */
                if (processingData->keep_comments)
                    processingData->mcpp_fputc('\n', OUT, processingData); /* May flush comments   */
                else
                    processingData->newlines++; /* Wait for a token     */
            }
            else
            {
                break; /* Actual token         */
            }
        }

        if (c == CHAR_EOF) /* Exit process at      */
            break;         /*   end of input       */

        /*
         * If the loop didn't terminate because of end of file, we
         * know there is a token to compile.  First, clean up after
         * absorbing newlines.  newlines has the number we skipped.
         */
        if (processingData->no_output)
        {
            processingData->wrong_line = FALSE;
        }
        else
        {
            if (processingData->wrong_line || processingData->newlines > 10)
            {
                sharp(NULL, 0, processingData); /* Output # line number */
                if (processingData->keep_spaces && processingData->src_col)
                {
                    while (processingData->src_col--) /* Adjust columns       */
                        processingData->mcpp_fputc(' ', OUT, processingData);
                    processingData->src_col = 0;
                }
            }
            else
            {                          /* If just a few, stuff */
                while (processingData->newlines-- > 0) /* them out ourselves   */
                    processingData->mcpp_fputc('\n', OUT, processingData);
            }
        }

        /*
         * Process each token on this line.
         */
        line_top = TRUE;
        while (c != '\n' && c != CHAR_EOF)
        { /* For the whole line   */
            /*
             * has_pragma is set to TRUE so as to execute _Pragma() operator
             * when the psuedo macro _Pragma() is found.
             */
            int has_pragma;

            if ((processingData->mcpp_debug & MACRO_CALL) && !processingData->in_directive)
            {
                line_col.line = processingData->src_line; /* Location in source   */
                line_col.col = processingData->infile->bptr - processingData->infile->buffer - 1;
            }
            
            if (scan_token(c, (wp = processingData->out_ptr, &wp), processingData->out_wend, processingData) == NAM && (defp = is_macro(&wp, processingData)) != NULL)
            {                                                                      /* A macro  */
                wp = processingData->expand_macro(defp, processingData->out_ptr, processingData->out_wend, line_col, &has_pragma); /* Expand it completely */

                if (line_top)
                { /* The first token is a macro   */
                    char *tp = processingData->out_ptr;
                    
                    while (processingData->char_type[*tp & UCHARMAX] & HSP)
                        tp++; /* Remove excessive spaces  */
                    
                    memmove(processingData->out_ptr, tp, strlen(tp) + 1);
                    wp -= (tp - processingData->out_ptr);
                }
                if (has_pragma)
                {                      /* Found _Pramga()      */
                    do_pragma_op(processingData);    /* Do _Pragma() operator*/
                    processingData->out_ptr = processingData->output;  /* Do the rest of line  */
                    processingData->wrong_line = TRUE; /* Line-num out of sync */
                }
                else
                {
                    processingData->out_ptr = wp;
                }

                if (processingData->keep_spaces && processingData->wrong_line && processingData->infile && *(processingData->infile->bptr) != '\n' && *(processingData->infile->bptr) != EOS)
                {
                    processingData->src_col = processingData->infile->bptr - processingData->infile->buffer;
                    /* Remember the current colums  */
                    break; /* Do sharp() now       */
                }
            }
            else
            {                   /* Not a macro call     */
                processingData->out_ptr = wp;   /* Advance the place    */

                if (processingData->wrong_line) /* is_macro() swallowed */
                    break;      /*      the newline     */
            }

            while (processingData->char_type[c = get_ch(processingData)] & HSP)
            {                     /* Horizontal space */
                if (c != COM_SEP) /* Skip 0-length comment*/
                    *processingData->out_ptr++ = c;
            }
            line_top = FALSE; /* Read over some token */
        }                     /* Loop for line        */

        putout(processingData->output, processingData); /* Output the line      */
    }                   /* Continue until EOF   */
}

static void do_pragma_op(processing_data_t* processingData)
/*
 * Execute the _Pragma() operator contained in an expanded macro.
 * Note: _Pragma() operator is also implemented as a special macro.  Therefore
 *      it is always searched as a macro.
 * There might be more than one _Pragma() in a expanded macro and those may be
 *      surrounded by other token sequences.
 * Since all the macros have been expanded completely, any name identical to
 *      macro should not be re-expanded.
 * However, a macro in the string argument of _Pragma() may be expanded by
 *      do_pragma() after de_stringize(), if EXPAND_PRAGMA == TRUE.
 */
{
    FILEINFO *file;
    DEFBUF *defp;
    int prev = processingData->output < processingData->out_ptr; /* There is a previous sequence */
    int token_type;
    char *cp1, *cp2;
    int c;

    file = unget_string(processingData->out_ptr, NULL, processingData);
    while (c = get_ch(processingData), file == processingData->infile)
    {
        if (processingData->char_type[c] & HSP)
        {
            *processingData->out_ptr++ = c;
            continue;
        }

        if (scan_token(c, (cp1 = processingData->out_ptr, &cp1), processingData->out_wend, processingData) == NAM && (defp = is_macro(&cp1, processingData)) != NULL && defp->nargs == DEF_PRAGMA)
        { /* _Pragma() operator   */
            if (prev)
            {
                putout(processingData->output, processingData);                  /* Putout the previous sequence */
                cp1 = stpcpy(processingData->output, "pragma "); /* From top of buffer   */
            }

            /* is_macro() already read over possible spaces after _Pragma   */
            *cp1++ = get_ch(processingData); /* '('  */
            
            while (processingData->char_type[c = get_ch(processingData)] & HSP)
                *cp1++ = c;
            
            if (((token_type = scan_token(c, (cp2 = cp1, &cp1), processingData->out_wend, processingData)) != STR && token_type != WSTR))
            {
                /* Not a string literal */
                put_seq(processingData->output, cp1, processingData);
                return;
            }

            processingData->workp = de_stringize(cp2, processingData->work_buf);
            
            while (processingData->char_type[c = get_ch(processingData)] & HSP)
                *cp1++ = c;

            if (c != ')')
            { /* More than a string literal   */
                unget_ch(processingData);
                put_seq(processingData->output, cp1, processingData);
                return;
            }

            strcpy(processingData->workp, "\n"); /* Terminate with <newline> */
            unget_string(processingData->work_buf, NULL, processingData);
            do_pragma(processingData);                          /* Do the #pragma "line"    */
            processingData->infile->bptr += strlen(processingData->infile->bptr); /* Clear sequence   */
            cp1 = processingData->out_ptr = processingData->output;               /* From the top of buffer   */
            prev = FALSE;
        }
        else
        { /* Not pragma sequence      */
            processingData->out_ptr = cp1;
            prev = TRUE;
        }
    }
    unget_ch(processingData);
    if (prev)
        putout(processingData->output, processingData);
}

static void put_seq(
    char *begin, /* Sequence already in buffer   */
    char *seq,   /* Sequence to be read          */
    processing_data_t* processingData
)
/*
 * Put out the failed sequence as it is.
 */
{
    FILEINFO *file = processingData->infile;
    int c;

    cerror("Operand of _Pragma() is not a string literal" /* _E_  */
           ,
           NULL, 0L, NULL, processingData);
    while (c = get_ch(processingData), file == processingData->infile)
        *seq++ = c;
    unget_ch(processingData);
    processingData->out_ptr = seq;
    putout(begin, processingData);
}

static char *de_stringize(
    char *in, /* Null terminated string literal   */
    char *out /* Output buffer        */
)
/*
 * Make token sequence from a string literal for _Pragma() operator.
 */
{
    char *in_p;
    int c1, c;

    in_p = in;
    if (*in_p == 'L')
        in_p++; /* Skip 'L' prefix      */
    while ((c = *++in_p) != EOS)
    {
        if (c == '\\' && ((c1 = *(in_p + 1), c1 == '\\') || c1 == '"'))
            c = *++in_p; /* "De-escape" escape sequence  */
        *out++ = c;
    }
    *--out = EOS; /* Remove the closing '"'       */
    return out;
}

static void putout(
    char *out, /* Output line (line-end is always 'out_ptr')   */
    processing_data_t* processingData
)
/*
 * Put out a line with or without "post-preprocessing".
 */
{
    size_t len;

    *processingData->out_ptr++ = '\n'; /* Put out a newline    */
    *processingData->out_ptr = EOS;

#if !MBCHAR_IS_ESCAPE_FREE
    post_preproc(out);
#elif !HAVE_DIGRAPHS
    if (mcpp_mode == STD && option_flag.dig)
        post_preproc(out);
#endif
    /* Else no post-preprocess  */
#if COMPILER != GNUC && COMPILER != MSC
    /* GCC and Visual C can accept very long line   */
    len = strlen(out);
    if (len > NWORK - 1)
        devide_line(out, processingData); /* Devide a too long line   */
    else
#endif
        put_a_line(out, processingData);
}

#if COMPILER != GNUC && COMPILER != MSC

static void devide_line(
    char *out, /* 'out' is 'output' in actual  */
    processing_data_t* processingData
)
/*
 * Devide a too long line into output lines shorter than NWORK.
 * This routine is called from putout().
 */
{
    FILEINFO *file;
    char *save;
    char *wp;
    int c;

    file = unget_string(out, NULL, processingData); /* To re-read the line  */
    wp = processingData->out_ptr = out;

    while ((c = get_ch(processingData)), file == processingData->infile)
    {
        if (processingData->char_type[c] & HSP)
        {
            if (processingData->keep_spaces || out == processingData->out_ptr || (processingData->char_type[*(processingData->out_ptr - 1) & UCHARMAX] & HSP))
            {
                *processingData->out_ptr++ = c;
                wp++;
            }
            continue;
        }

        scan_token(c, &wp, processingData->out_wend, processingData); /* Read a token     */

        if (NWORK - 2 < wp - processingData->out_ptr)
        {                                                   /* Too long a token */
            cfatal("Too long token %s", processingData->out_ptr, 0L, NULL, processingData); /* _F_  */
        }
        else if (processingData->out_end <= wp)
        { /* Too long line    */
            if (processingData->mcpp_debug & MACRO_CALL)
            { /* -K option        */
                /* Other than GCC or Visual C   */
                /* scan_token() scans a comment as sequence of some */
                /* tokens such as '/', '*', ..., '*', '/', since it */
                /* does not expect comment.                         */
                save = processingData->out_ptr;
                while ((save = strrchr(save, '/')) != NULL)
                {
                    if (*(save - 1) == '*')
                    {                       /* '*' '/' sequence */
                        processingData->out_ptr = save + 1; /* Devide at the end*/
                        break;              /*      of a comment*/
                    }
                }
            }
            save = save_string(processingData->out_ptr); /* Save the token   */
            *processingData->out_ptr++ = '\n';           /* Append newline   */
            *processingData->out_ptr = EOS;
            put_a_line(out, processingData);                  /* Putout the former tokens */
            wp = processingData->out_ptr = stpcpy(out, save); /* Restore the token    */
            free(save);
        }
        else
        {                 /* Still in size        */
            processingData->out_ptr = wp; /* Advance the pointer  */
        }
    }

    unget_ch(processingData);      /* Push back the source character   */
    put_a_line(out, processingData); /* Putout the last tokens   */
    sharp(NULL, 0, processingData);  /* Correct line number  */
}

#endif

static void put_a_line(char *out, processing_data_t* processingData)
/*
 * Finally put out the preprocessed line.
 */
{
    size_t len;
    char *out_p;
    char *tp;

    if (processingData->no_output)
        return;
    len = strlen(out);
    tp = out_p = out + len - 2; /* Just before '\n'     */
    
    while (processingData->char_type[*out_p & UCHARMAX] & SPA)
        out_p--; /* Remove trailing white spaces */

    if (out_p < tp)
    {
        *++out_p = '\n';
        *++out_p = EOS;
    }
    if (processingData->mcpp_fputs(out, OUT, processingData) == EOF)
        cfatal("File write error", NULL, 0L, NULL, processingData); /* _F_  */
}

/*
 *      Routines to  P O S T - P R E P R O C E S S
 *
 * 1998/08      created     kmatsui     (revised 1998/09, 2004/02, 2006/07)
 *    Supplementary phase for the older compiler-propers.
 *      1. Convert digraphs to usual tokens.
 *      2. Double '\\' of the second byte of multi-byte characters.
 *    These conversions are done selectively according to the macros defined
 *  in system.H.
 *      1. Digraphs are converted if ! HAVE_DIGRAPHS and digraph recoginition
 *  is enabled by DIGRAPHS_INIT and/or -2 option on execution.
 *      2. '\\' of the second byte of SJIS (BIGFIVE or ISO2022_JP) is doubled
 *  if bsl_need_escape == TRUE.
 */

#if HAVE_DIGRAPHS && MBCHAR_IS_ESCAPE_FREE
/* No post_preproc()    */
#else

static int post_preproc(
    char *out)
/*
 * Convert digraphs and double '\\' of the second byte of SJIS (BIGFIVE or
 * ISO2022_JP).
 * Note: Output of -K option embeds macro informations into comments.
 * scan_token() does not recognize comment and parses it as '/', '*', etc.
 */
{
#if !HAVE_DIGRAPHS
    int di_count = 0;
#endif
    int token_type;
    int c;
    char *str;
    char *cp = out;

    unget_string(out, NULL);
    while ((c = get_ch()) != '\n')
    { /* Not to read over to next line    */
        if (char_type[c] & HSP)
        {
            *cp++ = c;
            continue;
        }
        str = cp;
        token_type = scan_token(c, &cp, out_wend);
        switch (token_type)
        {
#if !MBCHAR_IS_ESCAPE_FREE
        case WSTR:
        case WCHR:
            str++; /* Skip prefix 'L'      */
            /* Fall through */
        case STR:
        case CHR:
            if (bsl_need_escape)
                cp = esc_mbchar(str, cp);
            break;
#endif /* ! MBCHAR_IS_ESCAPE_FREE  */
#if !HAVE_DIGRAPHS
        case OPE:
            if (mcpp_mode == STD && (openum & OP_DIGRAPH))
            {
                cp = conv_a_digraph(cp); /* Convert a digraph    */
                di_count++;
            }
            break;
#endif
        }
    }
    *cp++ = '\n';
    *cp = EOS;
#if !HAVE_DIGRAPHS
    if (mcpp_mode == STD && di_count && (warn_level & 16))
        cwarn("%.0s%ld digraph(s) converted" /* _W16_    */
              ,
              NULL, (long)di_count, NULL);
#endif
    return 0;
}

#endif /* ! HAVE_DIGRAPHS || ! MBCHAR_IS_ESCAPE_FREE   */

#if !HAVE_DIGRAPHS
static char *conv_a_digraph(
    char *cp /* The end of the digraph token */
)
/*
 * Convert a digraph to usual token in place.
 * This routine is never called in POST_STD mode.
 */
{
    cp -= 2;
    switch (openum)
    {
    case OP_LBRACE_D:
        *cp++ = '{';
        break;
    case OP_RBRACE_D:
        *cp++ = '}';
        break;
    case OP_LBRCK_D:
        *cp++ = '[';
        break;
    case OP_RBRCK_D:
        *cp++ = ']';
        break;
    case OP_SHARP_D: /* Error of source  */
        *cp++ = '#';
        break;
    case OP_DSHARP_D: /* Error of source  */
        cp -= 2;
        *cp++ = '#';
        *cp++ = '#';
        break;
    }
    return cp;
}
#endif /* ! HAVE_DIGRAPHS  */

#if !MBCHAR_IS_ESCAPE_FREE
static char *esc_mbchar(
    char *str,    /* String literal or character constant without 'L' */
    char *str_end /* The end of the token */
)
/*
 * Insert \ before the byte of 0x5c('\\') of the SJIS, BIGFIVE or ISO2022_JP
 * multi-byte character code in string literal or character constant.
 * Insert \ also before the byte of 0x22('"') and 0x27('\'') of ISO2022_JP.
 * esc_mbchar() does in-place insertion.
 */
{
    char *cp;
    int delim;
    int c;

    if (!bsl_need_escape)
        return str_end;
    if ((delim = *str++) == 'L')
        delim = *str++; /* The quote character  */
    while ((c = *str++ & UCHARMAX) != delim)
    {
        if (char_type[c] & mbchk)
        { /* MBCHAR   */
            cp = str;
            processingData->mb_read(c, &str, (workp = work_buf, &workp));
            while (cp++ < str)
            {
                c = *(cp - 1);
                if (c == '\\' || c == '"' || c == '\'')
                {
                    /* Insert \ before 0x5c, 0x22, 0x27 */
                    memmove(cp, cp - 1, (size_t)(str_end - cp) + 2);
                    *(cp++ - 1) = '\\';
                    str++;
                    str_end++;
                }
            }
        }
        else if (c == '\\' && !(char_type[*str & UCHARMAX] & mbchk))
        {
            str++; /* Escape sequence      */
        }
    }
    return str_end;
}
#endif /* ! MBCHAR_IS_ESCAPE_FREE  */